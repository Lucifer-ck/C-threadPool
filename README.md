**线程池原理**

我们使用线程的时候就去创建一个线程，这样实现起来非常的方便，但是会出现一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。

那么有没有一种方法使得线程可以复用，就是执行完一个任务，并不销毁，而是可以继续执行其他任务呢？

线程池就是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件），则线程池插入另一个辅助线程来使所有线程保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池在一段时间后创建另一个辅助线程但辅助线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其它线程完成后才启动。

==线程池实现原理==

- 线程池的组成主要分为三部分，这三部分配合工作就可以得到一个完整的线程池：

  1. 任务队列，存储需要处理的任务，有工作的线程来处理这些任务

     通过线程池提供的API函数，将一个待处理的任务添加到任务队列中，或者从任务队列中删除；

     已处理的任务从任务队列中删除；

     线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线。

  2. 工作的线程（任务队列的消费者），N个

     线程池中维护了一定数量的工作线程，他们的作用是不停的读任务队列，从里面取出任务并处理；

     工作的线程相当于是任务队列的消费者；

     如果任务队列为空时，工作的线程将会被阻塞（使用条件变量/信号量阻塞）[还需要配合着互斥锁使用]；

     如果阻塞之后有了新的任务，由生存者线程将阻塞解除，工作线程开始工作。

  3. 管理者线程（不处理任务队列中的任务，主要用来管理线程，添加线程和==引导==销毁线程）

     周期性的对任务队列中的任务数量以及忙状态下的工作线程数量进行检测；

     当任务过多时，可以适当的创建一些新的工作线程（根据需求来）；

     当任务过少时，可以适当的销魂一些工作线程（根据需求来）；

线程池结构体定义

```c
typedef struct Task
{
	void (*function)(void* arg);
	void* arg;
}Task;

// 线程池结构体
struct ThreadPool
{
	// 任务队列
	Task* taskQ;
	int queueCapacity; // 容量
	int queueSize; //当前任务个数
	int queueFront; // 队头
	int queueRear; // 队尾

	pthread_t managerID;  // 管理者线程ID
	pthread_t* threadIDs; // 工作线程ID数组
	int minNum;   // 工作的最小线程数
	int maxNum;   // 工作的最大线程数
	int busyNum;   // 忙线程数
	int liveNum; // 存活线程数
	int exitNum;  // 要销毁的线程数
	pthread_mutex_t mutexPool; // 锁整个线程池
	pthread_mutex_t mutexBusy; // 锁busyNum变量
	pthread_cond_t notFull;  // 任务队列是否满（生产者条件变量）
	pthread_cond_t notEmpty;  // 任务队列是否空（消费者条件变量）

	int shutdown;  // 是不是要销毁线程池，1为销毁，0为不销毁
};
```

